<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: http | ShareCore]]></title>
  <link href="http://sharecore.info/blog/categories/http/atom.xml" rel="self"/>
  <link href="http://sharecore.info/"/>
  <updated>2014-01-14T09:29:10+08:00</updated>
  <id>http://sharecore.info/</id>
  <author>
    <name><![CDATA[Justin Huang]]></name>
    <email><![CDATA[justinhuang917@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SPDY:更快的实验性网络协议]]></title>
    <link href="http://sharecore.info/blog/2013/03/17/spdy-whitepaper/"/>
    <updated>2013-03-17T17:39:00+08:00</updated>
    <id>http://sharecore.info/blog/2013/03/17/spdy-whitepaper</id>
    <content type="html"><![CDATA[<p>本文译自<a href="http://dev.chromium.org/spdy/spdy-whitepaper">Google SPDY白皮书</a></p>

<h2>内容摘要</h2>

<p>作为“让网络更快”倡议行动的一部分，我们尝试了一些有助于降低网络延迟的替代协议，SPDY("Speedy"的发音)就是其中之一。它是一个专注降低网络延迟的应用协议。除协议规范本身外，我们也在Google Chrome浏览器和开源的Web服务器中嵌入实现了它。通过实验室的测试，，比较HTTP与SDPY的性能发现，SPDY能降低超过64%的页面加载时间。我们也希望通过开源社区的献计献策，回馈，代码贡献和测试结果，来使SPDY成为加速网络的下一代应用协议。</p>

<h2>背景：网络协议与网络延迟</h2>

<p>如今，HTTP和TCP是主要的网络协议。TCP是通用的，可靠的传输协议,它提供了可靠传递，复制抑制，有序传递，流量控制，避免拥塞等其他传输特性。HTTP是一个应用层协议，它提供了基础的请求/响应语义。虽然我们相信能在传输层改善延迟的问题，但我们还是将最初的调研精力集中在了应用层的HTTP上。  <br/>
但是，HTTP并没有为延迟做特殊的设计。此外，今天的网页传输与10年前有着明显的区别,HTTP的改善需求，也不是开发它时能预见的。以下是HTTP中阻碍性能达到最佳的一些特性：</p>

<ul>
<li>一个连接一个请求。由于HTTP在一个时间点只能获取一个资源（HTTP pipelining机制能对此有作用，但它必须维护一个FIFO队列），服务器为防止其它请求对TCP通道的重用，将产生500ms的延迟。当然对于这个问题，浏览器可使用多个连接来变通解决。从2008年开始，大多数浏览器将一个域下的连接限制数从2调整到了6。</li>
<li>独占式的客户端初始化请求。在HTTP协议中，只有客户端能初始化请求，即使服务器知道客户端需要什么资源时也是如此，它没有一个能通知客户端的机制，而只能等待客户端的资源请求。</li>
<li>未压缩的请求/响应头信息。现在的请求头信息大小达到了200 bytes到2kb。当应用使用了cookie和user agent等扩展特性时，达到700-800kb大小的头信息变得很常见。而对于调制解调器和ASDL连接，其上行链路带宽是很小的，由此产生的延迟也将更明显。减少头信息中的数据，可以直接改善发送请求的串行化延迟。</li>
<li>冗余的头信息。许多头信息在相同的通道上重复发送。比如User-Agent,Host和Accept*这些静态信息，并不需要重复发送。</li>
<li>可选的数据压缩。HTTP的数据压缩是可选，内容并不总是通过一个压缩格式来传输发送。</li>
</ul>


<!--more-->


<h2>SPDY的目标</h2>

<p>SPDY项目定义和实现了一个能大幅降低延迟的应用层协议。
它的高级目标包括了：</p>

<ul>
<li>降低50%的页面加载时间。我们初步的结果已经接近这个目标了。</li>
<li>最小化部署的复杂性。SPDY使用TCP作为传输层，所以它不会要求对现有网络架构作出改变。</li>
<li>避免网站内容需要作出任何更新，而只需要更新客户端和服务器端支持SPDY。</li>
<li>汇集有兴趣来探讨解决网络延迟问题的志同道合人士。我们希望与开源社区和行业专家来开发这一个新的协议。</li>
</ul>


<p>技术目标：</p>

<ul>
<li>在一个TCP会话上并行执行多个HTTP请求。</li>
<li>通过压缩和清除不必要的头信息来降低对带宽的浪费。</li>
<li>协议易于实现和易于服务器端的高效。我们期望通过削减HTTP的一些边缘部分来降低复杂性，并使用一个容易解析的消息格式。</li>
<li>为了更高的安全性和兼容性，传输层使用SSL。尽管SSL对降低延迟无益，但是我们相信长远看来，互联网需要依赖一个安全的网络连接。同时，使用SSL，可以确保现有代理间通信不被破坏。</li>
<li>使服务端能发起与客户端的通信，可以任意时间想客户端推送数据。</li>
</ul>


<h2>SPDY的设计与特性</h2>

<p>SPDY在SSL之上添加了一个会话层，允许在统一个TCP连接上传输并发和交错的流。
HTTP GET/POST消息的用法还是一样的;但是，SPDY定义了一个新的帧格式来进行编码和线路上的传输。</p>

<p><img src="/images/spdy_whitepaper/spdy_basic.png" alt="SPDY Basic" /></p>

<p>流是双向的，即可以由服务器和客户端发起。
SPDY通过一些基本的特性（常用的）和一些高级特性（可选的）来达到降低延迟的目的：</p>

<p>基本特性：</p>

<ul>
<li>可复用的流
SPDY不限制在单个TCP连接上的并发流。由于请求都是位于同一个通道上，所以TCP的效率能高很多：更少的网络连接创建，更少和更密集的包发送。</li>
<li>请求优化
尽管无限制的并行流解决了顺序化问题，但是也产生了另外一个问题：如果信道的带宽受到限制，可能会组织客户端请求，以免堵塞信道。为了解决这个问题，SPDY实现了请求优先级：客户端可尽可能多的请求它想要的内容，同时对每个请求指定一个优先级。这可以避免当网络信道上有大量非关键资源时，高优先级的请求被挂起。</li>
<li>HTTP头压缩
SPDY压缩请求/响应头信息，可以建少数据包和字节的传输。</li>
</ul>


<p>高级特性：
 此外，SPDY提供了一个高级特性：服务端发起流。服务端发起流可以在客户端不发起资源请求的时候向客户端推送内容。这个选项可以由web开发者用下面两个方式来设置</p>

<ul>
<li>Server推送
SPDY实验通过头信息：X-Associated-Content，来推送数据到客户端。这个头用来通知客户端，在客户端发起请求前，服务端正在想客户端推送数据。对于初始页面下载（例如用户第一次访问网站），这可以极大地提升了用户体验。</li>
<li>Server暗示
相比与自动推送数据到客户端，在服务端预先知道客户端需要请求什么信息时，服务端用X-Subresources头信息，来建议客户端应该请求什么特定的资源。但是，服务端仍然需要等待客户端发送资源请求。在慢的链路上，这个选项可以减少客户端请求它要的资源的时间达几百毫秒，同时它或许对非初始化的页面加载有利。
更多的技术细节可参考：<a href="http://dev.chromium.org/spdy/spdy-protocol/spdy-protocol-draft1">SPDY草稿协议</a></li>
</ul>


<h2>SPDY的实现</h2>

<p>我们已经构建好：</p>

<ul>
<li>一个建立在TCP和SSL之上快速和内存级的服务器,它可以同时提供高效的HTTP与SPDY响应的。我们将在不久将来发布此代码到开源社区。</li>
<li>一个建立在TCP和SSL之上的，改进了的Google Chrome客户端，<a href="http://src.chromium.org/viewvc/chrome/trunk/src/net/spdy/.">代码在此</a>（注意当前使用的内部代码名称“flip”，不久后会更新）</li>
<li>一个测试和基准检验框架，可以用来校验一个页面是否被很好的复制了。尤其是，我们确保SPDY保留了原始的服务器头信息，内容编码，URL等。不久后，我们会发布我们的测试工具和重现结果说明。</li>
</ul>


<h2>初步结果</h2>

<p>在我们开发的Google Chrome和web服务器的原型上，我们执行了许多实验来比对SPDY与HTTP的效率：
我们模拟家庭网络，在1%的丢包率下，下载了25个"Top 100"的网站。我们对每个网站执行10次下载，计算每个网站的平均加载时间。结果显示，较于HTTP，在不使用SSL的情况下，速度提升27%-60%，使用SSL的情况下提升了39%-55%。</p>

<p><img src="/images/spdy_whitepaper/table1.png" alt="SPDY Result" /></p>

<ul>
<li>在很多情况下，SPDY可以在一个连接中处理多个请求，无论这些资源的请求是来自多少个不同的域下面，这也就提供了全并行的下载方式。但是，在一些情况下，将所有域整合进一个域下，是不可能的。在此情况下，SPDY仍然必须为每个域开一个连接,而每个连接的建立也就消耗了初始化的RTT。为此，我们在两个模式下运行了这些测试：聚合所有域到一个域下以及按资源来源分割多个域（即一个域一个TCP连接）。我们这包含了严格的“单域”和“多域”测试，我们期望真实世界的结果在两者之中。</li>
<li>关于头信息压缩
头压缩能降低大约88%的请求头大小和大约85%的响应头大小。在上行速度只有375Kbps的低带宽DSL链路上，请求头压缩能显著改善某些网站的页面加载速度（如一些需要发送大量的资源请求的站点）。我们发现只使用头压缩的情况下，能降低45-1142ms的页面加载速度。</li>
<li>关于丢包和往返时间（RTT）
我们做了第二次测试与确定丢包和往返时间（RTTs）对结果的影响。在这些测试中，我们仅测试了电缆链路，但是模拟了丢包和RTT的差异。
我们发现SPDY的延迟节省与丢包率的增加成比例，在2%的丢包率下能加速48%（2%以上增长逐渐减少，2.5%时完全消失。在现实世界中，丢包率大概在1-2%,往返时间平均是50-100ms在美国）。SPDY对丢包率的增长有反作用的原因有几个：</li>
<li>SPDY较HTTP节约了大概40%的包传送，这也意味这更少的包会丢失。</li>
<li>SPDT使用更少的TCP连接，这能使SYN包丢失的几率减少。在多数的TCP实现中，这种延迟过于昂贵（最高达3s）</li>
<li>SPDY的更有效的利用TCP触发TCP的快速重传，而不是使用重传定时器。
我们也发现SPDY的延迟节省与RTT的上升成比例，在200ms时达到27%的加速。SPDY能对RTT上升有作用是因为SPDY能并行获取所有请求。如果一个HTTP客户端在一个域下有4个连接，并有20个资源需要获取，获取20个资源项目大概需要5个来回。而SPDY获取20个资源只需要1个来回。</li>
</ul>


<p><img src="/images/spdy_whitepaper/spdy_lr_rtt.png" alt="SPDY Result" /></p>

<h2>SPDY下一步：您如何提供帮助</h2>

<p>我们初步的结果是令人鼓舞的，但是我们不知道它在真实世界中的表现。同时，SPDY还有许多需要改善的方面，特别是:</p>

<ul>
<li>带宽下率依然较低。尽管拨号带宽利用率接近90%，但用于高速连接的效率却大概只有32%。</li>
<li>SSL带来了其他的延迟和部署的挑战。主要有：SSL握手带来的往返时间增加；加密；代理上缓存的困难。我们仍需要在SLL的调优上做更多。</li>
<li>我们的丢包率测试结果不是结论性的。尽管做了需要关于丢包的研究，但是我们还是没有足够的数据来构建一个切实的模型来模拟互联网上的包丢失。我们需需要收集数据来完成更准确的丢失模拟。</li>
<li>SPDY的单连接在丢失恢复上表现不如多连接。也就是说，在RTT很高时，打开多连接仍然比丢失一个单连接快。我们需要弄清楚创建一个新连接还是关闭旧连接对SPDYk客户端更合适，以及由此造成的对服务器端的影响。</li>
<li>较于我们现在构建的，服务器的实现应该更智能。我们需要在服务端初始化流上和获取客户端网络预取建议的信息上等方面，做更多研究，</li>
</ul>


<p>为了帮助应付这些挑战，我们鼓励您的积极参与：</p>

<ul>
<li>发送反馈，评论，建议，想法到chromium-discuss讨论小组。</li>
<li>下载，编译，运行和测试Google Chrome客户端代码。</li>
<li>构建和改进代码</li>
</ul>


<h2>SPDY常见问题</h2>

<p>Q:<em>HTTP并行化是否已经解决了延迟问题？</em></p>

<p>A:没有！虽然并行化确实允许在一个TCP流上发送多个请求。但是它仍然是单一的流形式。流上的任何延迟（一个耗时的请求或者包丢失）仍将延迟整个流。并行化也已经被证明是难于部署的，因为它在所有主流浏览器中仍是默认被禁用的。</p>

<p>Q:<em>SPDY是HTTP的替代品吗？</em></p>

<p>A：不是！SPDY替换了HTTP的部分内容，但是大多数上只是增强它。在应用层顶部，请求/响应模型还是一样的。SPDY依旧使用HTTP Methods,头信息以及其他语义。但是SPDY重写了协议的其他部分，比如连接管理和数据传输格式。</p>

<p>Q:<em>为什么选择这个名字？</em></p>

<p>A: 我们想要名字带有“速度”之意。SPDY，是“SPeeDY”的发音，这一点也显示了如何通过压缩来提升速度。</p>

<p>Q:<em>SPDY会改变传输层吗？</em></p>

<p>A：还需要完成更多的研究来确定替代传输层是否有助于降低延迟。还有，替代传输层是一项复杂的工作，如果我们能在应用层克服效率低下的TCP和HTTP，那对于部署是一件简单的事情。</p>

<p>Q:<em>TCP在避免阻塞和网络崩溃上经过时间证明的，SPDY要打破这个格局吗?</em></p>

<p>A:不是！SPDY运行与TCP之上，它得益与TCP中所有的阻塞控制算法。更进一步，HTTP已经改变了互联网上的阻塞控制。例如，现在HTTP客户端同时与一个服务器建立6个连接;同时，一些服务器将初始阻塞窗口增加到了4个包。由于TCP独立于每个连接的节流限制，服务器能在初始化时高效地发送达24个数据包。多连接会受到TCP慢启动的影响，但在SPDY中，在一个连接中可以传输多个数据流。</p>

<p>Q:<em>SCTP如何？</em></p>

<p>A:SCTP是一个有趣的潜在传输层替代物。它提供了单一连接传输多个流的能力。但是，再一次说明，它需要改变传输层结构，这将使在现有家庭路由器的情况下，部署变得非常困难。同时，SCTP本身也不是“银弹”，应用层也必须能更高效地利用服务端和客户端之间的通道。</p>

<p>Q:<em>BEEP如何？</em></p>

<p>A：BEEP是一个有趣的协议，它提供了“一揽子”的类似特性，但是他不是关注于降低页面加载时间，在这方面它也缺少了一些特性。此外，它使用基于文本的协议来取代二进制帧。这对于一个易扩展的协议来说是一个很好的尝试，但是它由于比较难于正确解析，也带来了一些有趣的安全问题。</p>
]]></content>
  </entry>
  
</feed>
